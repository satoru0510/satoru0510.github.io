<!doctype html>
<html lang=ja>
<head>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="main.css">
<title>自作量子回路シミュレータ</title>
</head>

<body>
    <p>目次</p>
    <div class="index">
        <ul>
            <li><a href="#abstract">概要</a></li>
            <li><a href="#statevec">効率的な状態ベクトルシミュレータの実装</a></li>
            <li><a href="#density">密度演算子シミュレータの実装</a></li>
            <li><a href="#mps">MPSシミュレータの実装</a></li>
            <li><a href="#cuda">CUDA.jlによるカーネルプログラミング</a></li>
        </ul>
    </div>

    <h2 id="abstract">概要</h2>
    <a href="https://github.com/satoru0510/Jisaq">Jisaq.jl（github）</a>：量子回路シミュレータ<br>
    目的：
    <ol>
        <li>状態ベクトルシミュレータの高速な実装を理解する</li>
        <li>MPSの実装を理解する</li>
        <li><a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a>を用いたGPUのカーネルプログラミングを理解する</li>
        <li>Juliaのパッケージの作り方を理解する</li>
        <li>願わくば実用に耐える量子回路シミュレータにしたい</li>
    </ol>
    現在、1～4については概ね目標を達成できた。Juliaの代表的な量子回路シミュレータのパッケージ
    <a href="https://github.com/QuantumBFS/Yao.jl">Yao.jl</a>と比較したときの性能はこんな感じ。<br>
    <img src="assets/benchmark_jisaq_vs_yao.png" alt="benchmark_jisaq_vs_yao.png"><br>
    回路は1次元横磁場ハイゼンベルグモデル
    $$H = \sum_i X_i X_{i+1} + X_i X_{i+1} + Y_i Y_{i+1} + Z_i Z_{i+1} + X_i$$
    のTrotterizationの1ステップ分の回路。状態ベクトルシミュレータでCPU、GPUでの検証。
    JisaqはYaoよりも速い。スペックなどは以下の通り。
    <ul>
        <li>OS: Linux (x86_64-linux-gnu)</li>
        <li>CPU: 8 × Intel(R) Xeon(R) W-2245 CPU @ 3.90GHz</li>
        <li>GPU: NVIDIA RTX A6000</li>
    </ul>

    <h2 id="statevec">効率的な状態ベクトルシミュレータの実装</h2>
    <h2 id="density">密度演算子シミュレータの実装</h2>
    <h2 id="mps">MPSシミュレータの実装</h2>
    <h2 id="cuda">CUDA.jlによるカーネルプログラミング</h2>
    カーネルプログラミングとは、GPU上で動くコードを書くこと。
    <p></p>

    <a href="index.html">トップに戻る</a>
</body>
</html>